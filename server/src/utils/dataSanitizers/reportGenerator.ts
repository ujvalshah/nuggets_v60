/**
 * Generate sanitization reports in markdown format
 */

import { SanitizationReport, SanitizationIssue, CleanupCategory } from './types.js';
import { writeFile } from 'fs/promises';
import { join } from 'path';

export function generateReport(issues: SanitizationIssue[], dryRun: boolean): SanitizationReport {
  const byCategory: Record<CleanupCategory, number> = {
    SAFE_AUTO_FIX: 0,
    CONDITIONAL_CLEANUP: 0,
    DO_NOT_TOUCH: 0
  };

  const byCollection: Record<string, number> = {};

  let totalAffectedRecords = 0;

  for (const issue of issues) {
    byCategory[issue.category]++;
    byCollection[issue.collection] = (byCollection[issue.collection] || 0) + issue.count;
    totalAffectedRecords += issue.count;
  }

  return {
    timestamp: new Date().toISOString(),
    dryRun,
    issues,
    summary: {
      totalIssues: issues.length,
      totalAffectedRecords,
      byCategory,
      byCollection
    }
  };
}

export async function writeReportToFile(
  report: SanitizationReport,
  outputPath?: string
): Promise<string> {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `DATABASE_SANITIZATION_REPORT_${timestamp}.md`;
  const filepath = outputPath || join(process.cwd(), filename);

  const markdown = formatReportAsMarkdown(report);

  await writeFile(filepath, markdown, 'utf-8');
  return filepath;
}

function formatReportAsMarkdown(report: SanitizationReport): string {
  const { timestamp, dryRun, issues, summary } = report;

  let md = `# Database Sanitization Report\n\n`;
  md += `**Generated:** ${new Date(timestamp).toLocaleString()}\n`;
  md += `**Mode:** ${dryRun ? 'ðŸ” DRY RUN (No data modified)' : 'âš ï¸ EXECUTION MODE (Data modified)'}\n\n`;
  md += `---\n\n`;

  // Summary
  md += `## Summary\n\n`;
  md += `- **Total Issue Types:** ${summary.totalIssues}\n`;
  md += `- **Total Affected Records:** ${summary.totalAffectedRecords}\n\n`;

  md += `### By Category\n\n`;
  md += `| Category | Count |\n`;
  md += `|----------|-------|\n`;
  md += `| âœ… SAFE_AUTO_FIX | ${summary.byCategory.SAFE_AUTO_FIX} |\n`;
  md += `| âš ï¸ CONDITIONAL_CLEANUP | ${summary.byCategory.CONDITIONAL_CLEANUP} |\n`;
  md += `| ðŸš« DO_NOT_TOUCH | ${summary.byCategory.DO_NOT_TOUCH} |\n\n`;

  md += `### By Collection\n\n`;
  md += `| Collection | Affected Records |\n`;
  md += `|------------|------------------|\n`;
  for (const [collection, count] of Object.entries(summary.byCollection)) {
    md += `| ${collection} | ${count} |\n`;
  }
  md += `\n---\n\n`;

  // Detailed Issues
  md += `## Detailed Issues\n\n`;

  for (const issue of issues) {
    const categoryEmoji = {
      SAFE_AUTO_FIX: 'âœ…',
      CONDITIONAL_CLEANUP: 'âš ï¸',
      DO_NOT_TOUCH: 'ðŸš«'
    }[issue.category];

    md += `### ${categoryEmoji} ${issue.collection}: ${issue.description}\n\n`;
    md += `- **Type:** ${issue.issueType}\n`;
    md += `- **Category:** ${issue.category}\n`;
    md += `- **Count:** ${issue.count} records\n`;
    if (issue.field) {
      md += `- **Field:** \`${issue.field}\`\n`;
    }
    md += `- **Sample IDs:** ${issue.sampleIds.slice(0, 5).join(', ')}\n`;
    if (issue.details) {
      md += `- **Details:** ${JSON.stringify(issue.details, null, 2)}\n`;
    }
    md += `\n`;
  }

  md += `---\n\n`;
  md += `## Recommendations\n\n`;

  const safeAutoFixCount = summary.byCategory.SAFE_AUTO_FIX;
  const conditionalCount = summary.byCategory.CONDITIONAL_CLEANUP;
  const doNotTouchCount = summary.byCategory.DO_NOT_TOUCH;

  if (safeAutoFixCount > 0) {
    md += `### âœ… Safe Auto-Fix Issues (${safeAutoFixCount})\n\n`;
    md += `These issues can be automatically cleaned up safely:\n`;
    md += `- Orphaned references where parent entity no longer exists\n`;
    md += `- Invalid array entries pointing to non-existent documents\n`;
    md += `\n`;
  }

  if (conditionalCount > 0) {
    md += `### âš ï¸ Conditional Cleanup Issues (${conditionalCount})\n\n`;
    md += `These issues require manual review before cleanup:\n`;
    md += `- Audit trail data (reports, moderation logs)\n`;
    md += `- User-related data where user no longer exists\n`;
    md += `- Collections/articles with orphaned creators/authors\n`;
    md += `\n`;
  }

  if (doNotTouchCount > 0) {
    md += `### ðŸš« Do Not Touch Issues (${doNotTouchCount})\n\n`;
    md += `These issues are ambiguous or business-critical:\n`;
    md += `- Documents with missing required fields (may be critical data)\n`;
    md += `- Anything without clear ownership or lifecycle rules\n`;
    md += `\n`;
  }

  md += `---\n\n`;
  md += `*Report generated by Database Sanitization System*\n`;

  return md;
}








